"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EthereumEvents = void 0;

var _web = _interopRequireDefault(require("web3"));

var _ParseObject = _interopRequireDefault(require("./ParseObject"));

var _ParseQuery = _interopRequireDefault(require("./ParseQuery"));

var _ParseUser = _interopRequireDefault(require("./ParseUser"));

var _ParseACL = _interopRequireDefault(require("./ParseACL"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const EthereumEvents = {
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  ACCOUNTS_CHANGED: 'accountsChanged',
  CHAIN_CHANGED: 'chainChanged'
};
exports.EthereumEvents = EthereumEvents;
const WARNING = 'Non ethereum enabled browser';

function uniq(arr) {
  return arr.filter((v, i) => arr.indexOf(v) === i);
}

class MoralisWeb3 {
  constructor(...args) {
    const MWeb3 = typeof _web.default === 'function' ? _web.default : window.Web3;
    return new MWeb3(...args);
  }

  static async enable() {
    var _window$web;

    const MWeb3 = typeof _web.default === 'function' ? _web.default : window.Web3;
    const provider = (_window$web = window.web3) === null || _window$web === void 0 ? void 0 : _window$web.currentProvider;
    const ethereum = window.ethereum;

    if (provider !== null && provider !== void 0 && provider.isTrust) {
      return new MWeb3(provider);
    }

    if (ethereum) {
      const web3 = new MWeb3(ethereum);
      await ethereum.enable();
      return web3;
    }

    if (provider) {
      return new MWeb3(provider);
    }

    throw new Error(WARNING);
  }

  static async authenticate() {
    var _user$get;

    const isLoggedIn = await _ParseUser.default.current();

    if (isLoggedIn) {
      await _ParseUser.default.logOut();
    }

    const web3 = await MoralisWeb3.enable();
    const data = MoralisWeb3.getSigningData();
    const accounts = await web3.eth.getAccounts();
    const accountsLower = accounts.map(v => v.toLowerCase());
    const [ethAddress] = accountsLower;
    if (!ethAddress) throw new Error('Address not found');
    const signature = await web3.eth.personal.sign(data, ethAddress, '');
    if (!signature) throw new Error('Data not signed');
    const user = await _ParseUser.default.logInWith('moralisEth', {
      authData: {
        id: ethAddress,
        signature,
        data
      }
    });
    await user.setACL(new _ParseACL.default(user));
    if (!user) throw new Error('Could not get user');
    user.set('accounts', uniq([].concat(accountsLower, (_user$get = user.get('accounts')) !== null && _user$get !== void 0 ? _user$get : [])));
    user.set('ethAddress', ethAddress);
    await user.save();
    return user;
  }

  static async link(account) {
    var _user$get2;

    const web3 = await MoralisWeb3.enable();
    const data = MoralisWeb3.getSigningData();
    const user = await _ParseUser.default.current();
    const ethAddress = account.toLowerCase();

    const EthAddress = _ParseObject.default.extend('_EthAddress');

    const query = new _ParseQuery.default(EthAddress);
    const ethAddressRecord = await query.get(ethAddress).catch(() => null);

    if (!ethAddressRecord) {
      const signature = await web3.eth.personal.sign(data, account, '');
      await user.linkWith('moralisEth', {
        authData: {
          id: ethAddress,
          signature,
          data
        }
      });
    }

    user.set('accounts', uniq([ethAddress].concat((_user$get2 = user.get('accounts')) !== null && _user$get2 !== void 0 ? _user$get2 : [])));
    user.set('ethAddress', ethAddress);
    await user.save();
    return user;
  }

  static async unlink(account) {
    var _user$get3;

    const accountsLower = account.toLowerCase();

    const EthAddress = _ParseObject.default.extend('_EthAddress');

    const query = new _ParseQuery.default(EthAddress);
    const ethAddressRecord = await query.get(accountsLower);
    await ethAddressRecord.destroy();
    const user = await _ParseUser.default.current();
    const accounts = (_user$get3 = user.get('accounts')) !== null && _user$get3 !== void 0 ? _user$get3 : [];
    const nextAccounts = accounts.filter(v => v !== accountsLower);
    user.set('accounts', nextAccounts);
    user.set('ethAddress', nextAccounts[0]);
    await user._unlinkFrom('moralisEth');
    await user.save();
    return user;
  }

  static on(eventName, cb) {
    const ethereum = window.ethereum;

    if (!ethereum || !ethereum.on) {
      console.warn(WARNING);
      return () => {
        console.warn(WARNING);
      };
    }

    ethereum.on(eventName, cb);
    return () => {
      console.warn('UNSUB NOT SUPPORTED');
    };
  }

  static getSigningData() {
    return `Moralis Authentication`;
  }

}

MoralisWeb3.onConnect = MoralisWeb3.on.bind(MoralisWeb3, EthereumEvents.CONNECT);
MoralisWeb3.onDisconnect = MoralisWeb3.on.bind(MoralisWeb3, EthereumEvents.DISCONNECT);
MoralisWeb3.onChainChanged = MoralisWeb3.on.bind(MoralisWeb3, EthereumEvents.CHAIN_CHANGED);
MoralisWeb3.onAccountsChanged = MoralisWeb3.on.bind(MoralisWeb3, EthereumEvents.ACCOUNTS_CHANGED);
var _default = MoralisWeb3;
exports.default = _default;